# TODO: other architectures
ARCH = "x86_64"

# CONDA CONFIGURATION
CONDA_MAJOR = "3"
CONDA_MINOR = "py38_4.8.3"
CONDA_SHA = {
    "Windows": "1f4ff67f051c815b6008f144fdc4c3092af2805301d248b56281c36c1f4333e5",
    "MacOSX": "9b9a353fadab6aa82ac0337c367c23ef842f97868dcbb2ff25ec3aa463afc871",
    "Linux": "879457af6a0bf5b34b48c12de31d4df0ee2f06a8e68768e5758c3293b2daf688"
}
CONDA_INSTALLER_NAME_TEMPLATE = "Miniconda{major}-{minor}-{os}-{arch}.{ext}"
CONDA_BASE_URL = "https://repo.anaconda.com/miniconda/"
CONDA_INSTALLER_FLAGS = {
    "Windows": ["/InstallationType=JustMe", "/AddToPath=0", "/RegisterPython=0", "/S", "/D={}"],
    "MacOSX": ["-b", "-f", "-p", "{}"],
    "Linux": ["-b", "-f", "-p", "{}"]
}

OS_EXT_MAP = {
    "Windows": "exe",
    "MacOSX": "sh",
    "Linux": "sh"
}

INSTALLER_DIR = "installer"

CONDA_BUILD_FILE_TEMPLATE = """# This file was automatically generated by rules_conda

exports_files(['{conda}'])
"""


def _get_installer_flags(repository_ctx, dir):
    os = _get_os(repository_ctx)
    flags = CONDA_INSTALLER_FLAGS[os]
    # insert directory
    return flags[:-1] + [flags[-1].format(dir)]


def _get_os(repository_ctx):
    os_family = repository_ctx.os.name.lower()
    if "windows" in os_family:
        return "Windows"
    if "mac" in os_family:
        return "MacOSX"
    if "linux" in os_family or "unix" in os_family:
        return "Linux"
    fail("Unsupported OS: {}".format(os_family))


# download conda installer
def _download_conda(repository_ctx):
    repository_ctx.report_progress("Downloading conda installer")
    os = _get_os(repository_ctx)
    # TODO: check architecture also, for now downloading everything as 64 bit
    ext = OS_EXT_MAP[os]
    url = CONDA_BASE_URL + CONDA_INSTALLER_NAME_TEMPLATE.format(major=CONDA_MAJOR, minor=CONDA_MINOR, os=os, arch=ARCH, ext=ext)
    output = "{}/install.{}".format(INSTALLER_DIR, ext)
    # download from url to output
    repository_ctx.download(
        url = url,
        output = output,
        sha256 = CONDA_SHA[os],
        executable = True
    )
    return output


# install conda locally
def _install_conda(repository_ctx, installer):
    repository_ctx.report_progress("Installing conda")
    os = _get_os(repository_ctx)
    installer_flags = _get_installer_flags(repository_ctx, repository_ctx.attr.conda_dir)
    args = [installer] + installer_flags
    # execute installer with flags adjusted to OS
    result = repository_ctx.execute(args, quiet=repository_ctx.attr.quiet)
    if result.return_code:
        fail("Failure installing conda.\n{}\n{}".format(result.stdout, result.stderr))
    return "condabin/conda"


# use conda to update itself
def _update_conda(repository_ctx, executable):
    args = [executable, "update", "conda"]
    # update conda itself
    result = repository_ctx.execute(args, quiet=repository_ctx.attr.quiet, working_directory=repository_ctx.attr.conda_dir)
    if result.return_code:
        fail("Failure updating conda.\n{}\n{}".format(result.stdout, result.stderr))


# create BUILD file with exposed conda binary
def _create_conda_build_file(repository_ctx, executable):
    conda = "{}/{}".format(repository_ctx.attr.conda_dir, executable)
    repository_ctx.file(
        "BUILD",
        content = CONDA_BUILD_FILE_TEMPLATE.format(conda=conda)
    )


def _load_conda_impl(repository_ctx):
    installer = _download_conda(repository_ctx)
    executable = _install_conda(repository_ctx, installer)
    _update_conda(repository_ctx, executable)
    _create_conda_build_file(repository_ctx, executable)


load_conda_rule = repository_rule(
    _load_conda_impl,
    attrs = {
        "conda_dir": attr.string(mandatory=True),
        "quiet": attr.bool(
            default = True,
            doc = "False if conda output should be shown"
        )
    }
)